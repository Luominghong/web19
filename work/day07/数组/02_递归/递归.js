/**
 * 递归函数
 * 	一个函数在内部调用自身本身
 * 
 * 必须有退出条件，否则会无限递归造成栈溢出
 * 避免深度递归，递归调用的次数过多，会导致栈溢出
 * 
 * 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
 * 针对尾递归优化的语言可以通过尾递归防止栈溢出。
 * 	尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
 * 		尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
 * 		这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，
 * 		不会出现栈溢出的情况。
 * 遗憾的是，大多数编程语言没有针对尾递归做优化，所以即使采用了尾递归，递归太深也会导致栈溢出。
 */
function fn (num) {
	console.log(num);
	// 递归退出条件
	if (num === 0) {
		return
	}
	fn (num - 1);
}

// 打印 10 ~ 0
// function fn (num) {
// 	for (var i = num; i >= 0; i--) {
// 		console.log(i)
// 	}
// }

/**
 * 面试题
 * 	1 ~ 100 之间，求出能同时被3和5整除的数的总和? (要求使用递归实现)
 * 	1) 能被3和5整除的数(即能被15整除)
 * 	2) 求和
 */
function fn1 (num) {
	// 实际上小于15就可以退出
	if (num < 1) {
		return 0;
	}
	if (num % 15 === 0) {
		// 不是尾递归
		return num + fn1 (num - 1);
	}
	return fn1 (num - 1);
}
/**
 * 调用过程
 * 100 -> fn1(99)
 * ...
 * 90 -> 90 + fn1(89)
 * ...
 * 75 -> 90 + 75 + fn1(74)
 * ...
 * 15 -> 90 + 75 + 60 + 45 + 30 + 15 + fn1(14)
 * ...
 * 0 -> 90 + 75 + 60 + 45 + 30 + 15 + 0
 */

// 有全局变量，且递归应用不彻底
var sum = 0;
function fn2 (num) {
	if (num < 1) {
		return sum;
	}
	if (num % 15 === 0) {
		sum += num;
	}
	return fn2 (num - 1);
}

// 没有使用递归
function fn3 (num) {
	var total = 0;
	for (var i = 1; i <= num; i++){
		if (i % 3 === 0 && i % 5 === 0){
			total += i;
		}
	}
	return total;
}